lucidchart_export = file.path("inputs", "lucidchart_export.csv")    ###
#___________________________________________________________________###
#######################################################################
# qc_check_config()     # Quality Control Test # variables now entered on Lucidchart, can be optional.
source(file.path("amped_qc_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
source(file.path("amped_general_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
##################################################################################################
# Interpret data from exported Lucidchart shapes csv at /inputs/lucidchart_export.csv
##################################################################################################
source(file.path("amped_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
# source(file.path("amped_lucidchart_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
qc_check_lucidchart() # Quality Control Test
##################################################################
# Create the APPX doc if it doesn't exist
###################################################################
source(file.path("amped_appx_functions.R"), local = knitr::knit_global(), encoding = "UTF-8")  # Note: this will error/stop if the excel workbook is currently open/write locked
# if(appx_doesnt_exist_yet()){
make_blank_appx_doc() # from template, delete any existing appx doc
get_appx() # a blank one
construct_appx_from_lucidchart()
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10240m"))
knitr::opts_chunk$set
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = T)
sapply(pkg, require, character.only = T)
}
packages <- c(    "utf8",  "xlsx", "httr", "jsonlite", "readtext",  "R.utils",  "devtools", "tidyr", "lubridate", "magrittr",   "data.table", "readxl", "xlsx",    "tidyverse"  )
ipak(packages)
rm(packages,ipak)
wd = getwd()
# input_type = c("Lucidchart", "UML", "ttl") # Possible future option to read UML diagrams etc rather than Lucidchart
# new_artifacts_from_lucidchart = TRUE
#######################################################################
# Locate the CSV file of shapes data you exported from Lucidchart:  ###
#___________________________________________________________________###
lucidchart_export = file.path("inputs", "lucidchart_export.csv")    ###
#___________________________________________________________________###
#######################################################################
# qc_check_config()     # Quality Control Test # variables now entered on Lucidchart, can be optional.
source(file.path("amped_qc_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
source(file.path("amped_general_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
##################################################################################################
# Interpret data from exported Lucidchart shapes csv at /inputs/lucidchart_export.csv
##################################################################################################
source(file.path("amped_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
# source(file.path("amped_lucidchart_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
qc_check_lucidchart() # Quality Control Test
##################################################################
# Create the APPX doc if it doesn't exist
###################################################################
source(file.path("amped_appx_functions.R"), local = knitr::knit_global(), encoding = "UTF-8")  # Note: this will error/stop if the excel workbook is currently open/write locked
# if(appx_doesnt_exist_yet()){
make_blank_appx_doc() # from template, delete any existing appx doc
get_appx() # a blank one
construct_appx_from_lucidchart()
overwrite_appx_doc_from_script_data()   # Write to disk!
cat("Exported APPX!")
# } else { #- if it does exist...
# make a timestamped backup of the appx before overwriting
# file.copy(APPX_doc, file.path( "outputs", "archive",paste0("APPX-EDF_SEMANTIC_DD_TEMPLATE", datetimestamp,".xlsx")), APPX_doc)
# get_appx() # the existing one from data or file
# Re-create the appx data from lucidchart csv:
# construct_appx_from_lucidchart()
# write/overwrite the appx / updated appx to file
# overwrite_appx_doc_from_script_data()   # Write to disk!
# }
# ------------- At this point, modeler should fill in some data in the APPX doc...
#  - on excel sheets named: 05.Graph_Classes and 06. Graph_Properties, columns:
# - Label (as needed)
# - preflabel (as needed)
# - altLabel (as needed)
# - description (as needed)
# and if other config data wasn't entered above.... then also .....  // qc check -------!!!!!!!!!!!!!!!!! FIX ME !!!!!!!!!!
# #_______________________________
# #   Make the ttl file   #
# #_______________________________
source(file.path("amped_ttl_functions.R"), local = knitr::knit_global(), encoding = "UTF-8")
make_ttl()
cat("Exported Turtle!")
file <- APPX_doc
wb <- loadWorkbook(file)
sheets <- getSheets(wb)
domain_specific_properties_backup = domain_specific_properties
domain_specific_properties =  read.xlsx2(file,    sheetIndex = 8 , check.names = FALSE) %>% mutate_all(as.character)
domain_classes_backup = domain_classes
domain_classes = read.xlsx2(file,    sheetIndex = 7 , check.names = FALSE) %>% mutate_all(as.character) %>%
mutate(prefixedProperty = )
make_ttl()
View(domain_specific_properties)
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10240m"))
knitr::opts_chunk$set
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = T)
sapply(pkg, require, character.only = T)
}
packages <- c(    "utf8",  "xlsx", "httr", "jsonlite", "readtext",  "R.utils",  "devtools", "tidyr", "lubridate", "magrittr",   "data.table", "readxl", "xlsx",    "tidyverse"  )
ipak(packages)
rm(packages,ipak)
wd = getwd()
# input_type = c("Lucidchart", "UML", "ttl") # Possible future option to read UML diagrams etc rather than Lucidchart
# new_artifacts_from_lucidchart = TRUE
#######################################################################
# Locate the CSV file of shapes data you exported from Lucidchart:  ###
#___________________________________________________________________###
lucidchart_export = file.path("inputs", "lucidchart_export.csv")    ###
#___________________________________________________________________###
#######################################################################
# qc_check_config()     # Quality Control Test # variables now entered on Lucidchart, can be optional.
source(file.path("amped_qc_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
source(file.path("amped_general_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
##################################################################################################
# Interpret data from exported Lucidchart shapes csv at /inputs/lucidchart_export.csv
##################################################################################################
source(file.path("amped_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
# source(file.path("amped_lucidchart_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
qc_check_lucidchart() # Quality Control Test
##################################################################
# Create the APPX doc if it doesn't exist
###################################################################
source(file.path("amped_appx_functions.R"), local = knitr::knit_global(), encoding = "UTF-8")  # Note: this will error/stop if the excel workbook is currently open/write locked
# if(appx_doesnt_exist_yet()){
make_blank_appx_doc() # from template, delete any existing appx doc
get_appx() # a blank one
construct_appx_from_lucidchart()
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10240m"))
knitr::opts_chunk$set
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = T)
sapply(pkg, require, character.only = T)
}
packages <- c(    "utf8",  "xlsx", "httr", "jsonlite", "readtext",  "R.utils",  "devtools", "tidyr", "lubridate", "magrittr",   "data.table", "readxl", "xlsx",    "tidyverse"  )
ipak(packages)
rm(packages,ipak)
wd = getwd()
# input_type = c("Lucidchart", "UML", "ttl") # Possible future option to read UML diagrams etc rather than Lucidchart
# new_artifacts_from_lucidchart = TRUE
#######################################################################
# Locate the CSV file of shapes data you exported from Lucidchart:  ###
#___________________________________________________________________###
lucidchart_export = file.path("inputs", "lucidchart_export.csv")    ###
#___________________________________________________________________###
#######################################################################
# qc_check_config()     # Quality Control Test # variables now entered on Lucidchart, can be optional.
source(file.path("amped_qc_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
source(file.path("amped_general_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
##################################################################################################
# Interpret data from exported Lucidchart shapes csv at /inputs/lucidchart_export.csv
##################################################################################################
source(file.path("amped_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
# source(file.path("amped_lucidchart_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
qc_check_lucidchart() # Quality Control Test
##################################################################
# Create the APPX doc if it doesn't exist
###################################################################
source(file.path("amped_appx_functions.R"), local = knitr::knit_global(), encoding = "UTF-8")  # Note: this will error/stop if the excel workbook is currently open/write locked
# if(appx_doesnt_exist_yet()){
make_blank_appx_doc() # from template, delete any existing appx doc
get_appx() # a blank one
construct_appx_from_lucidchart()
#___________ obj Props #________________
df = tibble(myDomain) %>% as.df %>% unnest_wider(myDomain)  # this is working...
df_objectprops = df %>% select(className,classObjectProperties)
df_objectprops = df %>% select(className,classObjectProperties)  %>%
.[lapply(df_objectprops$classObjectProperties, is.list) == TRUE , ] %>%
select(classObjectProperties) %>% as.df
#----
objectProperties = objectProperties %>%
split_longer(col_to_split = "Property", "\u2028") %>% # targetClass still singular here...
unique()  %>% arrange(Property)
objectProperties$className= objectProperties$class %>%
gsub ("^[a-z-]*:", "", .) %>% gsub("--","-",.)
#----
df_objectprops$classObjectProperties = df_objectprops$classObjectProperties %>%
lapply(., function(x){
x = x %>% append(df_objectprops$className)
})
x = df_objectprops$classObjectProperties
x = x %>% unlist(recursive = F)
y = x[[1]] %>% tibble %>% t %>% as.df %>% setNames(names(x[[1]]))
for (i in seq_along(x)){
z = x[[i]] %>% tibble %>% t %>% as.df %>% setNames(names(x[[1]])) %>% bind_rows(y)
y = z
}
graph_object_properties = y %>% `row.names<-` (c()) %>%
mutate(`Property Type` = "object")
graph_object_properties$Min = "NA"
graph_object_properties$Max = "NA"
graph_object_properties$`scope notes` = NA  # adding here to leave space because ttl has property scope notes.
graph_object_properties$Label = graph_object_properties$propName %>% gsub("-"," ",.)
graph_object_properties$Label [graph_object_properties$standardNaming != TRUE] = ""
graph_object_properties$preflabel = graph_object_properties$propName %>% gsub("-"," ",.)
graph_object_properties$preflabel [graph_object_properties$standardNaming != TRUE] = ""
for (i in seq_along(graph_object_properties$targetClass)){
graph_object_properties$targetClass[[i]] = graph_object_properties$targetClass[[i]] %>% unique
}
graph_object_properties = graph_object_properties %>%
rename(c("Range/Datatype" = "targetClass",  "Inherited From" = "superProps",  "description" = "desc")) %>%
unique() %>%
arrange(propName) %>%
prefix_col("propName")
graph_object_properties[c("cardinality", "description", "altLabel")] = ""
graph_object_properties$Property = graph_object_properties$propName %>%
gsub ("^[a-z-]*:", "", .) %>% gsub("--","-",.)
graph_object_properties$Namespaces = graph_object_properties$propName %>% gsub(":.*", "", .)
graph_object_properties[["Inherited From"]] =   graph_object_properties[["Inherited From"]] %>% lapply(., function(x){
if( x[[1]] %>% is.na() %>% all() ) { x = ""} else {x = x}
})
graph_object_properties = graph_object_properties %>%
left_join(objectProperties %>% select(className,prefixedProperty), by = c("propName" = "prefixedProperty")) %>%
mutate(prefixedProperty = propName) %>%
rename("Class" = "className") %>%
mutate_all(as.character)
# graph_object_properties$prefixedProperty = graph_object_properties$propName
gProps = full_join(graph_data_properties,graph_object_properties)
gProps = gProps %>% replace(is.na(.), "")
gProps = gProps %>%
mutate(
across(everything(), ~gsub("NA","",.x))
)
df = tibble(myDomain) %>% as.df %>% unnest_wider(myDomain)
get_appx()
sheet <- sheets[[8]]  # for sheet "06. Graph_Properties"
df_dataprops = df %>% select(className,classDataProperties)  # no explanation, but found that removing this redundant line caused errors during testing...?
df_dataprops = df %>% select(className,classDataProperties)  %>%
.[lapply(df_dataprops$classDataProperties, is.list) == TRUE , ] %>%
select(classDataProperties) %>% as.df
dataProperties = dataProperties %>% split_longer(col_to_split = "Property", "\u2028")
df_dataprops$classDataProperties = df_dataprops$classDataProperties %>%
lapply(., function(x){
x = x %>% append(df_dataprops$className)
})
x = df_dataprops$classDataProperties
x = x %>% unlist(recursive = F)
y = x[[1]] %>% tibble %>% t %>% as.df %>% setNames(names(x[[1]]))
for (i in seq_along(x)){
z = x[[i]] %>% tibble %>% t %>% as.df %>% setNames(names(x[[1]])) %>% bind_rows(y)
y = z
}
graph_data_properties = y %>% `row.names<-` (c()) %>% rename(c("Min" = "min", "Max" = "max"))
graph_data_properties$`Property Type` = "datatype"
graph_data_properties$Label = graph_data_properties$propName %>% gsub("-"," ",.)
graph_data_properties$Label [graph_data_properties$standardNaming != TRUE] = ""
graph_data_properties$preflabel = graph_data_properties$propName %>% gsub("-"," ",.)
graph_data_properties$preflabel [graph_data_properties$standardNaming != TRUE] = ""
graph_data_properties$prefixedProperty = graph_data_properties$propName
graph_data_properties = graph_data_properties %>% prefix_col("prefixedProperty")
graph_data_properties$Namespaces = graph_data_properties$prefixedProperty %>% gsub(":.*", "", .)
graph_data_properties = graph_data_properties %>%
rename(c("Range/Datatype" = "datatype", "Property" = "propName",  "description" = "desc", "Inherited From" = "superProps")) %>%
mutate_all(as.character) %>%
left_join(dataProperties %>% select(class, Property), by = "Property") %>% un_prefix("class") %>% rename("Class" = "class") %>% mutate_all(as.character)
#___________ obj Props #________________
df = tibble(myDomain) %>% as.df %>% unnest_wider(myDomain)  # this is working...
df_objectprops = df %>% select(className,classObjectProperties)
df_objectprops = df %>% select(className,classObjectProperties)  %>%
.[lapply(df_objectprops$classObjectProperties, is.list) == TRUE , ] %>%
select(classObjectProperties) %>% as.df
#----
objectProperties = objectProperties %>%
split_longer(col_to_split = "Property", "\u2028") %>% # targetClass still singular here...
unique()  %>% arrange(Property)
objectProperties$className= objectProperties$class %>%
gsub ("^[a-z-]*:", "", .) %>% gsub("--","-",.)
#----
df_objectprops$classObjectProperties = df_objectprops$classObjectProperties %>%
lapply(., function(x){
x = x %>% append(df_objectprops$className)
})
x = df_objectprops$classObjectProperties
x = x %>% unlist(recursive = F)
y = x[[1]] %>% tibble %>% t %>% as.df %>% setNames(names(x[[1]]))
for (i in seq_along(x)){
z = x[[i]] %>% tibble %>% t %>% as.df %>% setNames(names(x[[1]])) %>% bind_rows(y)
y = z
}
graph_object_properties = y %>% `row.names<-` (c()) %>%
mutate(`Property Type` = "object")
graph_object_properties$Min = "NA"
graph_object_properties$Max = "NA"
graph_object_properties$`scope notes` = NA  # adding here to leave space because ttl has property scope notes.
graph_object_properties$Label = graph_object_properties$propName %>% gsub("-"," ",.)
graph_object_properties$Label [graph_object_properties$standardNaming != TRUE] = ""
graph_object_properties$preflabel = graph_object_properties$propName %>% gsub("-"," ",.)
graph_object_properties$preflabel [graph_object_properties$standardNaming != TRUE] = ""
for (i in seq_along(graph_object_properties$targetClass)){
graph_object_properties$targetClass[[i]] = graph_object_properties$targetClass[[i]] %>% unique
}
graph_object_properties = graph_object_properties %>%
rename(c("Range/Datatype" = "targetClass",  "Inherited From" = "superProps",  "description" = "desc")) %>%
unique() %>%
arrange(propName) %>%
prefix_col("propName")
graph_object_properties[c("cardinality", "description", "altLabel")] = ""
graph_object_properties$Property = graph_object_properties$propName %>%
gsub ("^[a-z-]*:", "", .) %>% gsub("--","-",.)
graph_object_properties$Namespaces = graph_object_properties$propName %>% gsub(":.*", "", .)
graph_object_properties[["Inherited From"]] =   graph_object_properties[["Inherited From"]] %>% lapply(., function(x){
if( x[[1]] %>% is.na() %>% all() ) { x = ""} else {x = x}
})
graph_object_properties = graph_object_properties %>%
left_join(objectProperties %>% select(className,prefixedProperty), by = c("propName" = "prefixedProperty")) %>%
mutate(prefixedProperty = propName) %>%
rename("Class" = "className") %>%
mutate_all(as.character)
# graph_object_properties$prefixedProperty = graph_object_properties$propName
gProps = full_join(graph_data_properties,graph_object_properties)
gProps = gProps %>% replace(is.na(.), "")
gProps = gProps %>%
mutate(
across(everything(), ~gsub("NA","",.x))
)
View(gProps)
test = "amg agt:subunit of"
test %>% gsub("[a-z :]","",.)
test %>% strsplit(":") %>% .[[2]]
test
test %>% gsub(".(?=:)", "",.)
test %>% gsub(".\(?=:\)", "",.)
test %>% gsub(".\\(?=:\\)", "",.)
test %>% gsub(".*\\(?=:\\)", "",.)
test %>% gsub("[a-z ]\\(?=:\\)", "",.)
look <- function(rx) str_view_all("bacad", rx)
look("a(?=c)")
look <- function(rx) str_view_all(test, rx)
look("a(?=c)")
look <- function(rx) str_view_all(test, rx)
look("a(?=:)")
look("[a-z ]*(?=:)")
test
test %>% gsub("[a-z ]*(?=:)","",.)
look("[a-z -]*(?=:)")
test %>% gsub("[a-z ]*(?=:)","",., perl = TRUE)
gProps$Label = gProps$Label  %>% gsub("[a-z ]*(?=:)","",., perl = TRUE) %>% gsub("^:","",.)
gProps$preflabel = gProps$preflabel  %>% gsub("[a-z ]*(?=:)","",., perl = TRUE) %>% gsub("^:","",.)
View(gProps)
View(gProps)
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10240m"))
knitr::opts_chunk$set
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = T)
sapply(pkg, require, character.only = T)
}
packages <- c(    "utf8",  "xlsx", "httr", "jsonlite", "readtext",  "R.utils",  "devtools", "tidyr", "lubridate", "magrittr",   "data.table", "readxl", "xlsx",    "tidyverse"  )
ipak(packages)
rm(packages,ipak)
wd = getwd()
# input_type = c("Lucidchart", "UML", "ttl") # Possible future option to read UML diagrams etc rather than Lucidchart
# new_artifacts_from_lucidchart = TRUE
#######################################################################
# Locate the CSV file of shapes data you exported from Lucidchart:  ###
#___________________________________________________________________###
lucidchart_export = file.path("inputs", "lucidchart_export.csv")    ###
#___________________________________________________________________###
#######################################################################
# qc_check_config()     # Quality Control Test # variables now entered on Lucidchart, can be optional.
source(file.path("amped_qc_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
source(file.path("amped_general_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
##################################################################################################
# Interpret data from exported Lucidchart shapes csv at /inputs/lucidchart_export.csv
##################################################################################################
source(file.path("amped_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10240m"))
knitr::opts_chunk$set
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = T)
sapply(pkg, require, character.only = T)
}
packages <- c(    "utf8",  "xlsx", "httr", "jsonlite", "readtext",  "R.utils",  "devtools", "tidyr", "lubridate", "magrittr",   "data.table", "readxl", "xlsx",    "tidyverse"  )
ipak(packages)
rm(packages,ipak)
wd = getwd()
# input_type = c("Lucidchart", "UML", "ttl") # Possible future option to read UML diagrams etc rather than Lucidchart
# new_artifacts_from_lucidchart = TRUE
#######################################################################
# Locate the CSV file of shapes data you exported from Lucidchart:  ###
#___________________________________________________________________###
lucidchart_export = file.path("inputs", "lucidchart_export.csv")    ###
#___________________________________________________________________###
#######################################################################
# qc_check_config()     # Quality Control Test # variables now entered on Lucidchart, can be optional.
source(file.path("amped_qc_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
source(file.path("amped_general_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
##################################################################################################
# Interpret data from exported Lucidchart shapes csv at /inputs/lucidchart_export.csv
##################################################################################################
source(file.path("amped_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
now()
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10240m"))
knitr::opts_chunk$set
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = T)
sapply(pkg, require, character.only = T)
}
packages <- c(    "utf8",  "xlsx", "httr", "jsonlite", "readtext",  "R.utils",  "devtools", "tidyr", "lubridate", "magrittr",   "data.table", "readxl", "xlsx",    "tidyverse"  )
ipak(packages)
rm(packages,ipak)
wd = getwd()
# input_type = c("Lucidchart", "UML", "ttl") # Possible future option to read UML diagrams etc rather than Lucidchart
# new_artifacts_from_lucidchart = TRUE
#######################################################################
# Locate the CSV file of shapes data you exported from Lucidchart:  ###
#___________________________________________________________________###
lucidchart_export = file.path("inputs", "lucidchart_export.csv")    ###
#___________________________________________________________________###
#######################################################################
# qc_check_config()     # Quality Control Test # variables now entered on Lucidchart, can be optional.
source(file.path("amped_qc_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
source(file.path("amped_general_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
##################################################################################################
# Interpret data from exported Lucidchart shapes csv at /inputs/lucidchart_export.csv
##################################################################################################
source(file.path("amped_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")   # creates a list named "myDomain" in the Global Environment
# if the file doesn't exist...
if(!file.exists(APPX_doc)){
make_blank_appx_doc()
### ----------------------------------------------- use the following for option to preserve modeler input
# if(!file.exists(modeler_input_appx)){
#   make_blank_appx_doc()
#
# } else if (file.exists(modeler_input_appx)){
#   APPX_doc = modeler_input_appx
# }
}
cat("
Getting appx from ", APPX_doc,"
")
cat("testing for ", domain_name, "modeling!")
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10240m"))
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = T)
sapply(pkg, require, character.only = T)
}
packages <- c(    # "httr", "jsonlite", "readxl",
"utf8", "readtext",  "R.utils",  "devtools", "tidyr", "lubridate", "magrittr", "data.table", "xlsx", "rlang",   "tidyverse"  )
ipak(packages)
rm(packages,ipak)
wd = getwd()
source(file.path("amped_qc_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
source(file.path("amped_general_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
source(file.path("amped_functions.R"), local = knitr::knit_global() , encoding = "UTF-8")
system("Rscript amped.r latest_lucidchart=T prebaked=T")
system("Rscript amped.r latest_lucidchart=T")
system("Rscript amped.r latest_lucidchart=T from_scratch=T")
system("Rscript amped.r latest_lucidchart=T edit_appx_now=T")
# Interpret a specific lucidchart export
system("Rscript amped.r find_lucidchart(20)")
cat(system("%CD%"))
# cat(
system("%CD%")
# cat(
system("echo %CD%")
# library(tidyverse)
get_this_file <- function(){
commandArgs() %>%
tibble::enframe(name=NULL) %>%
tidyr::separate(col=value, into=c("key", "value"), sep="=", fill='right') %>%
dplyr::filter(key == "--file") %>%
dplyr::pull(value)
}
this_file <- get_this_file()
this_file
wd
this_file
make_pkg = function(packageName){
# install.packages("devtools")
library("devtools")
# devtools::install_github("klutometis/roxygen")
library(roxygen2)
# During Furlough
# wd = paste0(Sys.getenv("HOME"),"\\R scripts\\bpn_packages")
# Back at work at CCL:
# wd = paste0(Sys.getenv("OneDrive"),"\\R scripts\\bpn_packages")
# on Goldfinger
wd <-  paste0("C:\\Users\\brend\\Mega\\R Scripts\\bpn_packages")
setwd (wd)
create(packageName)
setwd(paste0(wd,"\\",packageName))
# open the directory
# shell.exec(file.path(getwd(),"R"))
# Copy file to the package R directory
pkg_r_dir = file.path(getwd(),"R")
file.copy(from=file.choose(), to=file.path(pkg_r_dir,paste0(packageName,".R")),
overwrite = TRUE, recursive = FALSE,
copy.mode = TRUE)
}
make_pkg("sourceR")
document()
library(sourceR)
?round
?sourceR
make_pkg("sourceR")
document()
library(sourceR)
?sourceR
this_file = "sourceR.Rmd" ; source(file.path("R","sourceR.R")); sourceR(); source_ram(); source_wd(this_file);
this_file = "sourceR.Rmd" ; source(file.path("R","sourceR.R")); sourceR(); source_ram(); source_wd(this_file);
source_packages(c("dplyr", "readr", "stringr", "tidyr", "lubridate", "magrittr", "utf8", "readtext", "R.utils", "devtools", "rlang", "data.table", "xlsx", "keyring", "SPARQL", "httr", "jsonlite", "tidyverse"))
library(sourceR)
